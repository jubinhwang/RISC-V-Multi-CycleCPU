# RISC-V-Multi-CycleCPU
# 🚀 Single-Cycle에서 Multi-Cycle CPU로의 발전 배경

Single-Cycle CPU는 하나의 명령어를 처리하는 데 필요한 모든 작업을 단일 클럭 사이클 내에 완료합니다. 이는 구조가 단순하다는 장점이 있지만, **"가장 느린 명령어"**가 전체 시스템의 클럭 속도를 결정하는 치명적인 한계를 가집니다. Multi-Cycle CPU는 이 문제를 해결하기 위해 등장했습니다.

## 1. Single-Cycle CPU의 명확한 한계

### 🔹 "가장 느린 놈" 기준의 클럭 속도

Single-Cycle CPU의 클럭 주기(Clock Period)는 시스템에서 **가장 오래 걸리는 명령어(e.g., `lw`)**를 기준으로 설정되어야 합니다.

* **예시:**
    * 메모리 접근이 필요한 `lw` (Load Word) 명령어가 10ns 걸린다고 가정.
    * 단순 연산인 `add` 명령어는 7ns면 충분히 완료 가능.
* **문제점:**
    * 시스템의 클럭 주기는 10ns로 설정되어야 합니다.
    * `add` 명령어는 7ns면 충분함에도 불구하고 10ns의 사이클을 낭비하게 됩니다.
* **비유:** 모든 차가 가장 느린 차의 속도에 맞춰 달려야 하는 고속도로와 같습니다.

## 2. Multi-Cycle CPU의 해법

명령어 처리 과정을 여러 개의 작은 단계(Stage)로 분할하고, 각 단계 사이에 **파이프라인 레지스터 (D-Flip Flop)**를 삽입하여 각 단계의 결과를 다음 클럭에 전달합니다. (e.g., Fetch → Decode → Execute → MemAccess → WriteBack)

### 🔹 이점 1: 더 빠른 클럭 사용 가능 ⚡

* 클럭 주기는 '전체 과정'이 아닌 **'가장 오래 걸리는 1개 단계'**를 기준으로 설정됩니다.
* (예) Single-Cycle에서 10ns가 걸렸다면, Multi-Cycle에서 가장 긴 단계가 2ns일 경우, 클럭 주기를 2ns로 설정할 수 있습니다. (이론상 5배 빠른 클럭 주파수)

### 🔹 이점 2: 명령어별 최적화된 사이클 사용

* 모든 명령어가 5단계를 모두 거칠 필요가 없습니다.
* `lw` (Load): 5 사이클 (F-D-E-M-W)
* `add` (연산): 4 사이클 (F-D-E-W, MemAccess 불필요)
* `beq` (분기): 3 사이클 (F-D-E, Mem/WB 불필요)
* 명령어별로 필요한 사이클만 사용하므로 CPI (Clock Per Instruction)의 *평균값*이 개선되어 실제 처리량이 향상됩니다.

### 🔹 이점 3: 하드웨어 자원 재사용 (효율성)

* Single-Cycle에서는 한 클럭에 Fetch(명령어 메모리)와 MemAccess(데이터 메모리)가 동시에 필요할 수 있어 메모리가 2개 필요했습니다.
* Multi-Cycle에서는 Fetch(1단계)와 MemAccess(4단계)가 **서로 다른 클럭 사이클**에 일어나므로, **하나의 메모리 유닛**을 시분할하여 공유할 수 있습니다. (ALU 등 다른 자원도 마찬가지)

## 3. 요약 비교 테이블

| 항목 | Single-Cycle CPU | Multi-Cycle CPU |
| :--- | :--- | :--- |
| **클럭 주기** | **매우 김** (가장 느린 명령어 기준) | **매우 짧음** (가장 느린 *단계* 기준) |
| **CPI** | **1** (모든 명령어가 동일) | **명령어마다 다름** (평균 3~5) |
| **성능** | 클럭이 느려 전체 성능 저하 | 클럭이 빠르고, 사이클이 최적화되어 성능 향상 |
| **자원 사용** | 한 클럭에 모든 자원 사용 (자원 중복 필요) | 단계별 자원 사용 (자원 재사용 가능) |
| **제어 로직** | 단순함 | 복잡함 (현재 상태 추적 필요 - FSM) |

**결론:** Multi-Cycle CPU는 Single-Cycle의 **"느린 클럭 속도"**와 **"자원 낭비"**라는 비효율성을 해결합니다. 비록 명령어 하나당 *사이클 수(CPI)*는 늘어나지만, 훨씬 *빠른 클럭*을 사용하고 명령어별 사이클을 최적화함으로써 **전체적인 시스템 성능(Throughput)**을 극대화합니다.
